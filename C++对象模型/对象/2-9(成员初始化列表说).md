```c++
// project100.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <time.h >
using namespace std;
//
//class Base
//{
//public:
//	int ba;
//	int bb;
//	Base(int tmpa, int tmpb)
//	{
//	}
//};
//
//class CSub
//{
//public:
//	CSub(int tmpv)
//	{
//
//	}
//};
//
//class A:public Base
//{
//public:
//	int m_x;
//	int m_y;
//	int &m_yy;
//	const int m_myc;
//	CSub cmysub;
//	//A() :m_x(0), m_y(0)
//	A(int &tmpvalue):m_yy(tmpvalue), m_myc(tmpvalue),Base(tmpvalue, tmpvalue), cmysub(tmpvalue)
//	{
//		//m_myc = tmpvalue;
//		//m_yy = tmpvalue;
//		m_x = 0;
//		m_y = 0;
//		m_yy = 180;
//	}
//};

class X
{
public:
	int m_i;
	X(int value = 0) :m_i(value) //类型转换构造函数
	{
		printf("this = %p", this);
		cout << "X(int)构造函数被调用" << endl;
	}
	X(const X &tmpv)
	{
		printf("this = %p", this);
		cout << "X拷贝构造函数被调用" << endl;
	}
	X& operator=(const X &tmp)
	{
		printf("this = %p", this);
		cout << "X拷贝赋值运算符被调用" << endl;
		return *this;
	}
	~X()
	{
		printf("this = %p", this);
		cout << "X析构函数被调用" << endl;
	}
};

class A
{
public:
	X xobj; //类类型对象

	int m_test;
	int m_test2;

	//构造函数
	//A(int tmpvalue)   //这里却构造了xobj，耗费了一次调用构造函数的机会		       	
		//站在编译器视角
		/*X xobj;
		xobj.X::X();*/

	//大家把初始化列表中的代码看成是函数体内代码的一部分；
	//A(int tmpvalue) :xobj(1000), m_test2(100)/*,m_test(m_test2)*/ //这种代码是错误的
	A(int tmpvalue) :xobj(1000), m_test2(m_test),m_test(100)
		//站在编译器视角
		/*X xobj;
		xobj.X::X(1000)*/
	{	
		//m_test = m_test2;

		cout << "mtest = " << m_test << endl;
		cout << "mtest2 = " << m_test2 << endl;
		

		//m_test = 100; 
		
		//站在编译器视角
		//X tmpobj; //生成一个临时对象
		//tmpobj.X::X(1000); //临时对象调用构造函数
		//xobj.X::operator=(tmpobj); //调用的是xobj的拷贝赋值运算符。
		//tmpobj.X::~X(); //调用析构函数回收对象
		
		//xobj = 1000;  //构造一个临时对象，把临时对象内容给了xobj，释放掉临时对象
		//m_test = 500;
	}
};

int main()
{	
	//（1）何时必须用成员初始化列表
	//a)如果这个成员是个引用
	//b)如果是个const类型成员
	//c)如果你这个类是继承一个基类，并且基类中有构造函数，这个构造函数里边还有参数。
	//d)如果你的成员变量类型是某个类类型，而这个类的构造函数带参数时；

/*
	int abc = 1;
	A a(abc);
	cout << abc << endl;*/

	//（2）使用初始化列表的优势(提高效率)
	//除了必须用初始化列表的场合，我们用初始化列表还有什么其他目的？ 有，就是提高程序运行效率。
	//对于类类型成员变量xobj放到初始化列表中能够比较明显的看到效率的提升
	//但是如果是个简单类型的成员变量 比如 int m_test,其实放在初始化列表或者放在函数体里效率差别不大;
	//提醒：成员变量初始化尽量放在初始化列表里，显得 高端，大气上档次，考官对这个感兴趣。

	//（3）初始化列表细节探究
	//说明：
	//（3.1）初始化列表中的代码可以看作是被编译器安插到构造函数体中的，只是这些代码有些特殊；
	//（3.2）这些代码 是在任何用户自己的构造函数体代码之前被执行的。所以大家要区分开构造函数中的
	         //用户代码 和 编译器插入的 初始化所属的代码。
	//（3.3）这些列表中变量的初始化顺序是 定义顺序，而不是在初始化列表中的顺序。
	//老师 不建议 在初始化列表中 进行  两个 都在初始化列表中出现的成员之间的初始化


	A myaobj(1000);

	return 1;
}
```

**C/C++ - 类中成员变量是引用**
C++引用
引用在定义时必须初始化，否则编译时便会报错。如果类（自定义类型）的成员是引用类型，需要注意一些问题。

引用成员变量 并不为这个变量新辟空间；类对象做成员变量则是要对其新辟一段空间的

**不能有默认构造函数，必须提供构造函数**
凡是有引用类型的成员变量的类，不能有缺省构造函数。默认构造函数没有对引用成员提供默认的初始化机制，也因此造成引用未初始化的编译错误。

**构造函数的形参必须为引用类型**
暂时还不知道该怎么解释，牵涉到引用的机制。

**初始化必须在成员初始化链表内完成**
不能直接在构造函数里初始化，必须用到初始化列表，且形参也必须是引用类型。构造函数分为初始化和计算两个阶段，前者对应成员初始化链表，后者对应构造函数函数体。引用必须在初始化阶段，也即在成员初始化链表中完成，否则编译时会报错（引用未初始化）。

### 何时必须用成员初始化列表？

- 1）如果这个成员是一个引用【一般来说，如果成员是一个引用，那么构造函数都会携带参数】那么这种情况就必须在成员初始化列表中进行成员初始化
      

```c++
int abc =1;
    AS astem(abc);
    std::cout << abc << std::endl;  // 100 
```

 因为传递进构造函数的是一个引用，在构造函数里改变了该引用值，那么也就改变了abc的值
    

- 2)如果是一个const类型成员，就必须在成员初始化列表中初始化常量限定类型成员

- 3）如果一个类是继承某一个基类，并且该基类中有构造函数，并且构造函数里有参数，那么这种情况也必须使用初始化列表进行成员初始化

-  4）如果成员变量类型是某个类类型，并且这个类的构造函数也是带参数时，就必须用成员列表初始化

  ```c++
  class Base
  {
  public:
      int ba;
      int bb;
      
      // 注意这个构造函数，他不是默认的构造函数，而是带参数的构造函数，构造的时候就需要提供形参
      Base(int ta, int tb)
      {
          ba = ta;
          bb = tb;
      }
  };
  
  class CSUB
  {
  public:
      CSUB(int tmpv)
      {
          
      }
  };
  
  class AS:public Base
  {
    public:
      int m_x;
      int m_y;
      int &m_yy;
      const int m_mc;
      CSUB cs;
      
      // 一般就在构造函数和拷贝构造函数中会有成员的初始化列表
      AS(int &tmpvalue):m_yy(tmpvalue), m_mc(tmpvalue), Base(tmpvalue, tmpvalue), cs(tmpvalue)
      {
          m_x = 0;
          m_y = 0;
          m_yy = 100;
      }
  };
  ```

  

### 使用成员初始化列表的优势

除了上面的必须用初始化列表的场合，那么在其他情况下用初始化列表，有什么目的吗？

使用初始化列表的，就是为了提高程序运行效率

在理解初始化列表的时候，只需要把初始化列表理解为函数体中代码的一部分即可，只不过这种挪动是由编译器完成的
对于类类型变量放到初始化列表中初始化相较于在函数体内初始化能够有明显的效率提升
但是对于简单类型的初始化，在两个地方区别不大

总之，成员变量初始化尽量都放在初始化列表里

```c++
class XX
{
public:
    int m_i;
    
    // 类型转换构造函数
    XX(int value = 0):m_i(value)
    {
        printf("this = %p", this);
        std::cout << "构造函数被调用" << std::endl;
    }
    
    // 拷贝构造函数
    XX(const XX& tx):m_i(tx.m_i)
    {
        printf("this = %p", this);
        std::cout << "拷贝构造函数被调用" << std::endl;
    }
    
    // 拷贝赋值运算符
    XX& operator=(const XX& tmp)
    {
        printf("this = %p", this);
        std::cout << "拷贝赋值运算符被调用" << std::endl;
        return *this;
    }
    
    // 析构函数
    ~XX()
    {
        printf("this = %p", this);
        std::cout << "析构函数被调用" << std::endl;
    }
};

class AA
{
public:
    XX m_xx;        // 类类型对象
    int m_testi;
    
    // AA(int tx)      // this = 0x7ffd66a7f4b0构造函数被调用   这里构造了m_xx，那就意味着，这里耗费了一次掉用构造函数的机会
                    // 站在编译器的角度，这行做了什么事？
                    // XX m_xx;     // 生成临时对象
                    // m_xx.XX::XX();   // 调用构造函数
                    // 所以，在一个类里定义了一个类对象成员，那这个成员就是在这里进行构造的
    AA(int tx):m_xx(1000)   // 所以既然这里有一次调用构造的机会，那么为何不把这个参数直接在初始化列表里就给它呢！
                            // this = 0x7ffecb328d90构造函�被调用
                            // 这样写了之后，站在编译器的视角，这里做了什么事呢？
                            // XX m_xx;
                            // m_xx.XX::XX(1000);
    {
        // m_xx = 1000;    // 构造一个临时对象，把临时对象内容给了m_xx, 释放掉临时对象
        // this = 0x7ffd66a7f484构造函数被调用
        // this = 0x7ffd66a7f4b0拷贝赋值运算符被调用
        // this = 0x7ffd66a7f484析构函数被调用
        
        // 站在编译器的角度，m_xx = 1000； 这行代码做了什么事
        // XX tmpobj;   // 生成临时对象
        // tmpobj.XX::XX(1000);  // 这个临时对象调用构造函数构造自己
        // m_xx.XX::operator=(tmpobj); // 调用拷贝赋值运算符，将临时对象tmpobj的内容拷贝赋值给成员m_xx
        // tmpobj.XX::~XX();    // 临时对象调用析构函数进行释放
        
        // 即站在编译器的角度， m_xx = 1000 被转换成了这4行，这是很浪费性能的。
        
        m_testi = 500;
    }
};

int main()
{

    // 使用成员初始化列表的优势
    // 在理解初始化列表的时候，只需要把初始化列表理解为函数体中代码的一部分即可，只不过这种挪动是由编译器完成的
    // 对于类类型变量放到初始化列表中初始化相较于在函数体内初始化能够有明显的效率提升
    // 但是对于简单类型的初始化，在两个地方区别不大
    AA ma(1000);
    // this = 0x7ffd66a7f4b0构造函数被调用
    // this = 0x7ffd66a7f484构造函数被调用
    // this = 0x7ffd66a7f4b0拷贝赋值运算符被调用
    // this = 0x7ffd66a7f484析构函数被调用
    // this = 0x7ffd66a7f4b0析构函数被调用
    
    // 改为初始化列表初始化后
    
    // this = 0x7ffd66a7f4b0构造函数被调用
    // this = 0x7ffd66a7f4b0析构函数被调用
    
    
    return 0;
}
```

### 初始化列表细节探究

1. 初始化列表中的代码，可以看做是被编译器安插到构造函数体中的，只是这些代码有些特殊

2. 这些初始化列表中的代码是在任何用户自己的构造函数体代码执行之前就被执行了，所以要区分构造函数中的所谓用户代码和编译器插入的初始化所属的代码，编译器插入的代码会优先于所有用户代码最先执行

3. 这些列表中的变量的初始化顺序是 定义顺序 ，而不是在初始化列表中的顺序

   ```c++
   class A
   {
       public:
       	int m_1;
       	int m_2;
       A():m_2(100), m_1(m_2)
       {
           
       }
   };
   ```

   比如这种初始化列表就是错误的，因为在成员变量定义的时候，是先 m_1, 然后m_2，所以在初始化列表中也是先进行m_1的初始化，也就是先调用的m_1(m_2)，但是这个时候m_2是没有值的或者说是一个随机值。所以也是这个原因，不建议在成员初始化列表中进行两个都在初始化列表中出现的成员之间的赋值

   

