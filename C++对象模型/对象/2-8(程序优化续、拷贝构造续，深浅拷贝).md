```c++
// project100.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <time.h >
using namespace std;


class X
{
public:
	int m_i;
	int *p_mi;
	X(const X& tmpx)
	{
		p_mi = new int(100); //我们自己创建内存 
		memcpy(p_mi, tmpx.p_mi, sizeof(int)); //把目标对象的内存内容拷贝过来，叫深拷贝。

		m_i = tmpx.m_i;
		cout << "拷贝构造函数被调用" << endl;
	}
	
	X() //缺省构造函数
	{
		p_mi = new int(100);
		m_i = 0;
		cout << "构造函数被调用" << endl;
	}
	~X()
	{
		delete p_mi;
		cout << "析构函数被调用" << endl;
	}
	//explicit X(int value) :m_i(value) //类型转换构造函数
	X(int value) :m_i(value) //类型转换构造函数
	{
		p_mi = new int(100);
		cout << "X(int)构造函数被调用" << endl;
	}
};


int main()
{
	//第九节  程序优化续、拷贝构造续，深浅拷贝
	//cout << "--------begin-----------" << endl;
	//X x10(1000);
	//cout << "-------------------" << endl;
	//X x11 = 1000; //隐式类型转换
	//cout << "-------------------" << endl;
	//X x12 = X(1000);
	//cout << "-------------------" << endl;
	//X x13 = (X)1000;
	//cout << "--------end-----------" << endl;

	从编译器视角（不优化）
	第一行
	//X x10;
	//x10.X::X(1000);
	后边三行
	//X _tmp0; 
	//_tmp0.X::X(1000);//带一个参数的构造函数被调用
	//X x12;
	//x12.X::X(_tmp0); //拷贝构造函数被调用
	//_tmp0.X::~X(); //调用析构。

	//总结：当编译器面临用一个类对象作为另外一个类对象初值的情况，各个编译器表现不同。但是所有编译器都为了提高效率而努力。
	 //我们也没有办法确定我们自己使用的编译器是否一定会调用拷贝构造函数。

	//拷贝构造函数是否必须有？ 不一定，视情况而定。
	//如果你只有一些简单的成员变量类型，int,double，你会发现你根本不需要拷贝构造函数；编译器内部本身就支持成员变量的
	       //bitwise(按位) copy 按位拷贝
	X x0;
	x0.m_i = 150;
	
	X x1(x0); //有自己的拷贝构造函数编译器是必然会调用的。
	cout << x1.m_i << endl; //编译器支持bitwise拷贝，所以x1.m_i = 150;

	//当需要处理很复杂的成员变量类型的时候。
	//因为我们增加了自己的拷贝构造函数，导致编译器本身的bitwise拷贝能力失效，所以结论：
	         //如果你增加了自己的拷贝构造函数后，就要对各个成员变量的值的初始化负责了；
	//深浅拷贝问题；


	

	return 1;
}

```