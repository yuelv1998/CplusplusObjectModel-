```c++
// project100.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#include <iostream>
#include <time.h >
using namespace std;

class X
{
public:
	int x;
	int y;
	int z;
	//X() :x(0), y(0), z(0)
	X()
	{
		//编译器角度 伪码；
		//vptr = vtbl; //下边的memset会把vptr（虚函数表指针）清0

		memset(this, 0, sizeof(X));
		cout << "构造函数被执行" << endl;
	}
	//X(const X &tm) :x(tm.x), y(tm.y), z(tm.z)
	X(const X &tm)
	{
		memcpy(this, &tm, sizeof(X));
		cout << "拷贝构造函数被执行" << endl;
	}
	virtual ~X()
	{
		cout << "析构函数被执行" << endl;
	}
	virtual void virfunc()
	{
		cout << "虚函数virfunc()被执行" << endl;
	}
	void ptfunc()
	{
		cout << "普通函数ptfunc()被执行" << endl;
	}
};
int main()
{	
	//第六节  单纯的类不纯时引发的虚函数调用问题
	// 单纯的类:比较简单的类，尤其不包含 虚函数和虚基类。
	//X x0;  //调用构造函数
	///*x0.x = 100;
	//x0.y = 200;
	//x0.z = 300;*/
	//x0.virfunc(); //虚函数表指针为null居然可以成功调用虚函数；

	//X x1(x0); //调用拷贝构造函数
	//cout << "x1.x=" << x1.x << " x1.y=" << x1.y << " x1.z=" << x1.z << endl;

	//如果类并不单纯，那么在构造函数中使用如上所示的memset或者拷贝构造函数中使用如上所示的memcpy方法，
	//那么就会出现程序崩溃的情形；
	//那就是某些情况下，编译器会往类内部增加一些我们看不见 但真实存在的成员变量（隐藏成员变量），
	//有了这种变量的类，就不单纯了；
	//同时，这种隐藏的成员变量的 增加(使用) 或者赋值的时机，
	//往往都是在 执行构造函数或者拷贝构造函数的函数体之前进行。
	//那么你如果使用memset,memcpy，很可能把编译器给隐藏变量的值你就给清空了，要么覆盖了；

	//比如你类中增加了虚函数，系统默认往类对象中增加 虚函数表指针，
	//这个虚函数表指针就是隐藏的成员变量。

	//X *px0 = new X();
	//px0->ptfunc(); //正常调用
	//px0->virfunc(); //无法正常调用
	//delete px0; //无法正常调用
	//new出来的对象，虚函数变得无法正常执行了；

	//对多台，虚函数，父类子类。虚函数，主要解决的问题父类指针指向子类对象这种情况。
	//只有虚函数，没有继承，那么虚函数和普通函数有啥区别呢？ 老师认为此时就没啥时机区别。


	int i = 9;
	printf("i的地址 = %p\n", &i);
	X x0;
	printf("ptfunc()的地址=%p\n", &X::ptfunc); //打印正常的成员函数地址。
	//long *pvptrpar = (long *)(&x0);
	//long *vptrpar = (long *)(*pvptrpar);
	//printf("virfunc的地址 = %p\n", vptrpar[1]);//虚函数virfunc地址
	x0.ptfunc();
	x0.virfunc(); //不叫多态，属于静态联编
	//我们推断：这个函数ptfunc()和virfunc()函数，是在编译的就确定好的；
	//静态联编 和动态联编。
	//静态联编 ：我们编译的时候就能确定调用哪个函数。把调用语句和倍调用函数绑定到一起；
	//动态联编：是在程序运行时，根据时机情况，动态的把调用语句和被调用函数绑定到一起，
	//动态联编一般旨有在多态和虚函数情况下才存在。

	X *pX0 = new X();
	pX0->ptfunc();
	pX0->virfunc(); //通过虚函数表指针，找虚函数表，然后从虚函数表中找到virfunc虚函数的地址并调用。

	//更明白：虚函数，多态，这种概念专门给指针或者引用用的；
	X &xy = *pX0;
	xy.virfunc();
	X &xy2 = x0;
	xy2.virfunc();


	return 1;
}
```

通常来说联编就是将模块或者函数合并在一起生成可执行代码的处理过程，同时对每个模块或者函数调用分配内存地址，并且对外部访问也分配正确的内存地址，它是计算机程序彼此关联的过程。按照联编所进行的阶段不同，可分为两种不同的联编方法：**静态联编**和**动态联编**。

静态联编是指在编译阶段就将函数实现和函数调用关联起来，因此静态联编也叫早绑定，在编译阶段就必须了解所有的函数或模块执行所需要检测的信息，它对函数的选择是基于指向对象的指针（或者引用）的类型，C语言中，所有的联编都是静态联编,并且任何一种编译器都支持静态联编。

动态联编是指在程序执行的时候才将函数实现和函数调用关联，因此也叫运行时绑定或者晚绑定，动态联编对函数的选择不是基于指针或者引用，而是基于对象类型，不同的对象类型将做出不同的编译结果。C++中一般情况下联编也是静态联编，但是一旦涉及到多态和虚拟函数就必须要使用动态联编了。

对于 X x1;【这种直接在栈上生成一个对象】和 X *x2 = new X();【这种在堆上new一个对象】，前者是静态联编，直接调用，后者是查询虚函数表，然后调用。所以通过这种区别，更能明白 虚函数，多态这种概念是专门给指针或者引用来使用的

引用：

```c++
X x0;
X &x2 = x0;
```
测试代码

```c++
#include <stdio.h>
#include <iostream>
#include <cstring>

class X
{
public:
    int x;
    int y;
    int z;
    
    // X():x(0),y(0),z(0)
    X()
    {
        // 编译器视角 伪码
        // vptr = vtbl;    // 下面的memset就会把vptr【虚函数表指针】清零
        memset(this, 0, sizeof(X));
        std::cout << "构造函数被执行" << std::endl;
    }
    
    // X(const X& tmpx):x(tmpx.x),y(tmpx.y),z(tmpx.z)
    X(const X& tmpx)
    {
        memcpy(this, &tmpx, sizeof(X));
        std::cout << "拷贝构造函数被执行" << std::endl;
    }
    
    virtual ~X()
    {
        std::cout << "虚析构函数被执行了" << std::endl;
    }
    
    virtual void virFunc()
    {
        std::cout << "virFunc被执行" << std::endl;
    }
    
    void ptFunc()
    {
        std::cout << "ptFunc被执行" << std::endl;
    }
};

int main()
{
    // 单纯的类不纯时引发的虚函数调用问题
    // 单纯的类：比较简单的类，尤其不包含 虚函数和虚基类
    
    X x0;           // 调用构造函数
    x0.x = 100;
    x0.y = 200;
    x0.z = 300;
    
    X x1(x0);       // 调用拷贝构造函数
    std::cout << "x1.x = " << x1.x << std::endl;
    std::cout << "x1.y = " << x1.y << std::endl;
    std::cout << "x1.z = " << x1.z << std::endl;
    
    // 如果类并不单纯，那么在 构造函数/拷贝构造函数 中使用如上【memset,memcpy】写法，
    // 就会出现程序崩溃的情况
    // 不单纯，就是指编译器会往类内部中增加某些我们看不见，但是真实存在的成员变量（隐藏成员变量）
    // 同时，这种隐藏的成员变量的增加/使用/赋值的时机往往就是在执行构造函数/拷贝构造函数的函数体执行之前进行
    // 这时候如果使用memset/memcpy，很可能就把编译器给的隐藏变量值就给覆盖清空了，这样类内部的内存空间的内容就改变了，那这必然就会造成程序上的错误
    
    // 比如在类中增加了虚函数，系统默认会往类中增加虚函数表指针，这个虚函数表指针就是隐藏的成员变量
    x0.virFunc();   // 即便虚函数表指针被清空【虚函数表指针为NULL】，这种在栈中创建的对象也能成功调用虚函数
    
    
    std::cout << "-//-/-/-/-/-/-/-/-/-/-/-/-/-/-/-" << std::endl;
    // 那么换一种写法，在堆中new一个对象
    X *x3 = new X();
    x3->ptFunc();   // 普通成员函数可以正常调用
    x3->virFunc();  // 通过虚函数表指针去找虚函数表，然后通过虚函数表项进行虚函数调用
    // 但是可惜的是，在我们的构造函数写法中，因为使用了memset将虚函数表指针清空了，所以该行代码调用会出异常
    delete x3;
    
    // 发现，new出来的对象在这种memset情况下，就没办法正常调用虚函数、虚析构函数
    
    long *vtbl = (long *)(&x0);
    if (*vtbl != 0)
    {
        long *vptr = (long *)(* vtbl);
        
        std::cout << vptr[0] << std::endl;
        
        typedef void(*Func)(void);
        
        // Func f1 = (Func)vptr[1];
        Func f2 = (Func)vptr[2];
        
        // f1();
        f2();
    }
    
    // 对于多态，虚函数，父类子类，虚函数主要解决的问题是父类指针指向子类对象这种情况
    // 如果有虚函数，但是没有继承关系，那么虚函数和普通函数有什么区别呢？如果没有继承关系，那么虚函数其实和普通函数没有区别
    
    x0.ptFunc();
    x0.virFunc();   // 不叫多态，属于静态联编，在编译期间就已经将该虚函数的地址确定好了，可以直接调用
    
    // 这个普通函数ptFunc和虚函数virFunc这两个函数，他们的地址是在编译的时候就已经确定好了
    // 静态联编 和 动态联编
    // 静态联编：编译的时候就能确定调用哪个函数，也就是编译的时候就把调用语句和被调用函数绑定到一起
    // 动态联编：是在程序运行时，根据实际运行情况，动态的把调用语句和被调用函数绑定到一起，动态联编一般只在多态和虚函数的情况下才存在
    
    // 所以，这种 【X x0; 】 直接定义的对象，是在编译的时候就已经确定好了，没有多态的说法
    
    return 0;
}

```

